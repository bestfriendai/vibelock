rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Enhanced security function to validate user data
    function isValidUserData() {
      return request.resource.data.keys().hasAll(['id', 'email', 'createdAt']) &&
             request.resource.data.id == request.auth.uid &&
             request.resource.data.email is string &&
             request.resource.data.email.size() >= 3 &&
             request.resource.data.email.matches('^[^@]+@[^@]+\\.[^@]+$') &&
             request.time == request.resource.data.createdAt;
    }

    // Users: public read; writes restricted to owner with data validation
    match /users/{userId} {
      allow read: if true;
      allow create: if request.auth != null && 
                      request.auth.uid == userId && 
                      isValidUserData();
      allow update: if request.auth != null && 
                      request.auth.uid == userId &&
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['updatedAt', 'location', 'preferences']);
      allow delete: if false; // Users cannot delete their accounts via Firestore
    }

    // Reviews: public read; creation requires authorId == auth.uid; updates by author only,
    // except like/dislike counters which any authenticated user may update.
    match /reviews/{reviewId} {
      allow read: if true;
      allow create: if request.auth != null
        && request.auth.uid != null
        && request.resource.data.authorId == request.auth.uid
        && request.resource.data.keys().hasAll(['id', 'authorId', 'content', 'createdAt'])
        && request.resource.data.content.size() >= 1
        && request.resource.data.content.size() <= 5000;

      // Allow author to update any field, or any authed user to update only like/dislike counters
      allow update: if request.auth != null && (
        // Owner full update with validation
        (request.auth.uid == resource.data.authorId &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['content', 'updatedAt', 'rating'])) ||
        // Limited community counters update (only like/dislike)
        (request.writeFields.size() == (("likeCount" in request.writeFields ? 1 : 0) + ("dislikeCount" in request.writeFields ? 1 : 0)) &&
         request.resource.data.likeCount >= 0 &&
         request.resource.data.dislikeCount >= 0)
      );

      // Only the author can delete
      allow delete: if request.auth != null && request.auth.uid == resource.data.authorId;

      // Comments within reviews
      match /comments/{commentId} {
        allow read: if true;
        allow create: if request.auth != null
          && request.auth.uid != null
          && request.resource.data.authorId == request.auth.uid
          && request.resource.data.content.size() >= 1
          && request.resource.data.content.size() <= 1000;
        // Allow like/dislike updates by any authed user (and updatedAt)
        allow update: if request.auth != null && (
          request.writeFields.size() == (("likeCount" in request.writeFields ? 1 : 0) + ("dislikeCount" in request.writeFields ? 1 : 0)) &&
          request.resource.data.likeCount >= 0 &&
          request.resource.data.dislikeCount >= 0
        );
        // Only the comment author can delete
        allow delete: if request.auth != null && request.auth.uid == resource.data.authorId;
      }
    }

    // Chat rooms are publicly readable; writes restricted (basic) for app flow.
    match /chatRooms/{roomId} {
      allow read: if true;
      // Allow authenticated users to update lastActivity/lastMessage only
      allow write: if request.auth != null && (
        // Restrict writes to these fields to support sendMessage flow
        (request.writeFields.size() <= 2 &&
         request.writeFields.hasOnly(['lastActivity', 'lastMessage'])) ||
        // Allow creation by admins in future; currently keep minimal
        false
      );

      // Messages within chat rooms
      match /messages/{messageId} {
        allow read: if true;
        allow create: if request.auth != null
          && request.auth.uid != null
          && request.auth.uid == request.resource.data.senderId
          && request.resource.data.content.size() >= 1
          && request.resource.data.content.size() <= 5000
          && request.resource.data.timestamp <= request.time;
        allow update, delete: if false;
      }
    }

    // Default deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
